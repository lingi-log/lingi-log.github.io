(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{278:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"이왕이면-제네릭-타입으로-만들라"}},[t._v("이왕이면 제네릭 타입으로 만들라")]),t._v(" "),a("ul",[a("li",[t._v("클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기가 편하다.")]),t._v(" "),a("li",[t._v("새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있게 하라.")]),t._v(" "),a("li",[t._v("기존 타입 중 제네릭타입 이었어야 하는 게 있다면 제네릭으로 변경하자")])]),t._v(" "),a("h2",{attrs:{id:"e와-같은-실체화-불가-타입을-어떻게-배열로-만들까"}},[a("code",[t._v("E")]),t._v("와 같은 실체화 불가 타입을 어떻게 배열로 만들까?")]),t._v(" "),a("ol",[a("li",[t._v("제네릭 배열 생성 금지를 대놓고 우회\n"),a("ul",[a("li",[t._v("Object 배열을 생성한 다음 제네릭 배열로 형변환")]),t._v(" "),a("li",[t._v("일반적으로 타입안전하지 않다.")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("elements "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("code",[t._v("E")]),t._v(" 대신 "),a("code",[t._v("Object")]),t._v(" 사용"),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@SupressWarnings")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"unchecked"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" elements"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])]),t._v(" "),a("p",[t._v("1번 방법은 가독성이 더 좋다. 또한 형변환을 배열 생성시 한번만 해주면 된다. 하지만 2번은 배열에서 원소를 읽을 때마다 형변환을 해줘야 한다. 하지만 (E가 Object가 아닌 이상) 배열의 런타임 타입이 컴파일타임 타입과 달라 힙오염을 일으킨다.")]),t._v(" "),a("h2",{attrs:{id:"item28과-배치되는-내용-아닌가"}},[t._v("Item28과 배치되는 내용 아닌가?")]),t._v(" "),a("ul",[a("li",[t._v("제네릭 타입 안에서 리스트를 쓰는 것이 항상 가능한 것은 아니다. 꼭 더 좋다고 할수도 없음.")]),t._v(" "),a("li",[a("code",[t._v("ArrayList")]),t._v("같은 제네릭 타입도 결국 기본 타입인 배열을 통해 구현 함.")]),t._v(" "),a("li",[a("code",[t._v("HashMap")]),t._v("은 성능을 높이기 위해 배열 사용.")])])])}),[],!1,null,null,null);s.default=e.exports}}]);