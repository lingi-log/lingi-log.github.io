(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{267:function(t,_,v){"use strict";v.r(_);var r=v(0),e=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"계승하는-대신-구성하라"}},[t._v("계승하는 대신 구성하라")]),t._v(" "),v("p",[t._v("계승은 코드 재사용을 돕는 강력한 도구지만, 항상 최선이라고는 할 수 없다. 계승을 적절히 사용하지 못한 소프트웨어는 깨지기 쉽다.")]),t._v(" "),v("h2",{attrs:{id:"계승은-캡슐화-원칙을-위반한다"}},[t._v("계승은 캡슐화 원칙을 위반한다.")]),t._v(" "),v("p",[t._v("하위 클래스가 정상동작하기 위해서는 상위 클래스의 구현에 의존할 수밖에 없다. 상위 클래스의 구현은 릴리즈가 거듭되면서 바뀔 수 있는데, 그러다 보면 하위 클래스 코드는 수정된 적이 없어도 망가질 수 있다. 하위 클래스는 상위 클래스의 변화에 발맞춰 진화해야 한다.")]),t._v(" "),v("p",[t._v("캡슐화 원칙을 위반하면서 생기는 문제는 "),v("a",{attrs:{href:"https://lingi04.github.io/study/book/object/10-%EC%83%81%EC%86%8D%EA%B3%BC_%EC%BD%94%EB%93%9C_%EC%9E%AC%EC%82%AC%EC%9A%A9.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("오브젝트 10장 상속과 코드 재사용"),v("OutboundLink")],1),t._v("에 정리를 해 두었다.")]),t._v(" "),v("h2",{attrs:{id:"구성을-사용"}},[t._v("구성을 사용")]),t._v(" "),v("p",[t._v("기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 private 필드를 하나 두면 된다. 새로운 클래스에 포함된 메서드는 기존 클래스에 있는 메서드 가운데 필요한 것을 호출해서 그 결과를 반환하면 된다.")]),t._v(" "),v("h3",{attrs:{id:"구성으로-만들어진-클래스는-견고하다"}},[t._v("구성으로 만들어진 클래스는 견고하다.")]),t._v(" "),v("p",[t._v("기존 클래스의 구현 세부사항에 종속되지 않기 때문이다. 기존 클래스에 또 다른 메서드가 추가되더라도, 새로 만든 클래스에는 영향이 없을 것이다.")]),t._v(" "),v("h2",{attrs:{id:"정리"}},[t._v("정리")]),t._v(" "),v("ul",[v("li",[t._v("계승은 강력한 도구이지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다.")]),t._v(" "),v("li",[t._v("상위 클래스와 하위 클래스 사이에 IS-A 관계가 있을때만 사용하는 것이 좋지만")]),t._v(" "),v("li",[t._v("이 경우에도 상위 클래스와 하위 클래스가 다른 패키지에 있거나 계승을 고려해 만들어진 상위클래스가 아니면 하위클래스는 깨지기 쉽다.")]),t._v(" "),v("li",[t._v("이 문제를 피하기 위해 구성과 전달(구성된 클래스의 메서드를 호출 해 결과 전달) 기법을 사용하는 것이 좋다.")])])])}),[],!1,null,null,null);_.default=e.exports}}]);