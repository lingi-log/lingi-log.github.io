<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>10. 상속과 코드 재사용 | Lingi04</title>
    <meta name="description" content="개발 관련 이것 저것">
    
    
    <link rel="preload" href="/assets/css/0.styles.4b6fa609.css" as="style"><link rel="preload" href="/assets/js/app.1ac8e472.js" as="script"><link rel="preload" href="/assets/js/2.2f398f54.js" as="script"><link rel="preload" href="/assets/js/64.a6b87c8a.js" as="script"><link rel="prefetch" href="/assets/js/10.d4a80777.js"><link rel="prefetch" href="/assets/js/11.fea99847.js"><link rel="prefetch" href="/assets/js/12.258fbb1b.js"><link rel="prefetch" href="/assets/js/13.aa7cd9fc.js"><link rel="prefetch" href="/assets/js/14.b55cad91.js"><link rel="prefetch" href="/assets/js/15.715c7473.js"><link rel="prefetch" href="/assets/js/16.0c71b086.js"><link rel="prefetch" href="/assets/js/17.e871d0fa.js"><link rel="prefetch" href="/assets/js/18.9287c09f.js"><link rel="prefetch" href="/assets/js/19.25288eff.js"><link rel="prefetch" href="/assets/js/20.c1d508a8.js"><link rel="prefetch" href="/assets/js/21.ac4d3914.js"><link rel="prefetch" href="/assets/js/22.9bb43966.js"><link rel="prefetch" href="/assets/js/23.14e2eac5.js"><link rel="prefetch" href="/assets/js/24.fcbf8df3.js"><link rel="prefetch" href="/assets/js/25.67802c13.js"><link rel="prefetch" href="/assets/js/26.35ac2a96.js"><link rel="prefetch" href="/assets/js/27.12f0db9a.js"><link rel="prefetch" href="/assets/js/28.e6301139.js"><link rel="prefetch" href="/assets/js/29.41f5368b.js"><link rel="prefetch" href="/assets/js/3.b3bbe8ab.js"><link rel="prefetch" href="/assets/js/30.cd3049c1.js"><link rel="prefetch" href="/assets/js/31.97e4aaf0.js"><link rel="prefetch" href="/assets/js/32.eb37a6c4.js"><link rel="prefetch" href="/assets/js/33.6f30c75f.js"><link rel="prefetch" href="/assets/js/34.ea35f454.js"><link rel="prefetch" href="/assets/js/35.10b1c933.js"><link rel="prefetch" href="/assets/js/36.72207db9.js"><link rel="prefetch" href="/assets/js/37.d363ac7f.js"><link rel="prefetch" href="/assets/js/38.df47cb06.js"><link rel="prefetch" href="/assets/js/39.73e81b60.js"><link rel="prefetch" href="/assets/js/4.d7ee998c.js"><link rel="prefetch" href="/assets/js/40.67c8bb77.js"><link rel="prefetch" href="/assets/js/41.39683a1e.js"><link rel="prefetch" href="/assets/js/42.99ea81b1.js"><link rel="prefetch" href="/assets/js/43.277f2c7e.js"><link rel="prefetch" href="/assets/js/44.594960c1.js"><link rel="prefetch" href="/assets/js/45.323c69d8.js"><link rel="prefetch" href="/assets/js/46.e95e52d6.js"><link rel="prefetch" href="/assets/js/47.591ab3a3.js"><link rel="prefetch" href="/assets/js/48.270db365.js"><link rel="prefetch" href="/assets/js/49.666ea254.js"><link rel="prefetch" href="/assets/js/5.e74b6197.js"><link rel="prefetch" href="/assets/js/50.7e1da9f0.js"><link rel="prefetch" href="/assets/js/51.ffbdc893.js"><link rel="prefetch" href="/assets/js/52.ad03b774.js"><link rel="prefetch" href="/assets/js/53.247b1629.js"><link rel="prefetch" href="/assets/js/54.0eaae830.js"><link rel="prefetch" href="/assets/js/55.dd6ce2f2.js"><link rel="prefetch" href="/assets/js/56.c6d1520c.js"><link rel="prefetch" href="/assets/js/57.21ff5ea5.js"><link rel="prefetch" href="/assets/js/58.fcbf8fee.js"><link rel="prefetch" href="/assets/js/59.b8131e29.js"><link rel="prefetch" href="/assets/js/6.b4ec9f4c.js"><link rel="prefetch" href="/assets/js/60.77a00312.js"><link rel="prefetch" href="/assets/js/61.dfe09a57.js"><link rel="prefetch" href="/assets/js/62.a674480e.js"><link rel="prefetch" href="/assets/js/63.155a5f15.js"><link rel="prefetch" href="/assets/js/65.f193374c.js"><link rel="prefetch" href="/assets/js/66.ba7c2421.js"><link rel="prefetch" href="/assets/js/67.742f3382.js"><link rel="prefetch" href="/assets/js/68.07e733e5.js"><link rel="prefetch" href="/assets/js/69.dff53089.js"><link rel="prefetch" href="/assets/js/7.1e9a546b.js"><link rel="prefetch" href="/assets/js/70.cc810a88.js"><link rel="prefetch" href="/assets/js/71.d5ac1c27.js"><link rel="prefetch" href="/assets/js/72.946b1793.js"><link rel="prefetch" href="/assets/js/73.a897a3e6.js"><link rel="prefetch" href="/assets/js/74.c1475324.js"><link rel="prefetch" href="/assets/js/75.d70aebde.js"><link rel="prefetch" href="/assets/js/76.78afbc80.js"><link rel="prefetch" href="/assets/js/77.4ddb28f5.js"><link rel="prefetch" href="/assets/js/78.a45bdf4c.js"><link rel="prefetch" href="/assets/js/79.97f3fd22.js"><link rel="prefetch" href="/assets/js/8.09056a9a.js"><link rel="prefetch" href="/assets/js/80.078b562d.js"><link rel="prefetch" href="/assets/js/81.189295ce.js"><link rel="prefetch" href="/assets/js/82.48d69560.js"><link rel="prefetch" href="/assets/js/9.a3851888.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4b6fa609.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/thumbnail.png" alt="Lingi04" class="logo"> <span class="site-name can-hide">Lingi04</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study/" class="nav-link router-link-active">Study</a></div><div class="nav-item"><a href="/backend/" class="nav-link">Backend</a></div><div class="nav-item"><a href="/programming/Immutable.html" class="nav-link">Programming</a></div><div class="nav-item"><a href="/experiences/" class="nav-link">Experiences</a></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study/" class="nav-link router-link-active">Study</a></div><div class="nav-item"><a href="/backend/" class="nav-link">Backend</a></div><div class="nav-item"><a href="/programming/Immutable.html" class="nav-link">Programming</a></div><div class="nav-item"><a href="/experiences/" class="nav-link">Experiences</a></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Design Pattern</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/designpattern/1_observer.html" class="sidebar-link">Observer Pattern</a></li><li><a href="/study/designpattern/2_proxy.html" class="sidebar-link">Proxy Pattern</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Algorithm</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Leet Code</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/algorithm/algorithm_leet_46-50.html" class="sidebar-link">46번 ~ 50번</a></li><li><a href="/study/algorithm/algorithm_leet_51-60.html" class="sidebar-link">51번 ~ 60번</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>책</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>오브젝트</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/book/object/2-객체지향프로그래밍.html" class="sidebar-link">2. 객체지향 프로그래밍</a></li><li><a href="/study/book/object/3-역할_책임_협력.html" class="sidebar-link">3. 역할, 책임, 협력</a></li><li><a href="/study/book/object/4-설계_품질과_트레이드오프.html" class="sidebar-link">4. 설계 품질과 트레이드오프</a></li><li><a href="/study/book/object/5-책임_할당하기.html" class="sidebar-link">5. 책임 할당하기</a></li><li><a href="/study/book/object/6-메시지와_인터페이스.html" class="sidebar-link">6. 메시지와 인터페이스</a></li><li><a href="/study/book/object/7-객체_분해.html" class="sidebar-link">7. 객체 분해</a></li><li><a href="/study/book/object/8-의존성_관리하기.html" class="sidebar-link">8. 의존성 관리하기</a></li><li><a href="/study/book/object/9-유연한_설계.html" class="sidebar-link">9. 유연한 설계</a></li><li><a href="/study/book/object/10-상속과_코드_재사용.html" class="active sidebar-link">10. 상속과 코드 재사용</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/book/object/10-상속과_코드_재사용.html#_00-선요약" class="sidebar-link">00. 선요약</a></li><li class="sidebar-sub-header"><a href="/study/book/object/10-상속과_코드_재사용.html#_01-상속과-중복-코드" class="sidebar-link">01. 상속과 중복 코드</a></li><li class="sidebar-sub-header"><a href="/study/book/object/10-상속과_코드_재사용.html#_02-취약한-기반-클래스-문제" class="sidebar-link">02. 취약한 기반 클래스 문제</a></li><li class="sidebar-sub-header"><a href="/study/book/object/10-상속과_코드_재사용.html#_03-상속을-제대로-사용하기" class="sidebar-link">03. 상속을 제대로 사용하기</a></li></ul></li><li><a href="/study/book/object/11-합성과_유연한_설계.html" class="sidebar-link">11. 합성과 유연한 설계</a></li><li><a href="/study/book/object/12-다형성.html" class="sidebar-link">12. 다형성</a></li><li><a href="/study/book/object/15-디자인_패턴과_프레임워크.html" class="sidebar-link">15. 디자인 패턴과 프레임워크</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>이펙티브자바</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/book/effectivejava/rule13.html" class="sidebar-link">클래스와 멤버의 접근 권한은 최소화하라.</a></li><li><a href="/study/book/effectivejava/rule14.html" class="sidebar-link">public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라.</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_10-상속과-코드-재사용">10. 상속과 코드 재사용</h1> <p>상속은 클래스를 재사용하기 위한 가장 대표적 기법 이다.</p> <h2 id="_00-선요약">00. 선요약</h2> <p>상속으로 인한 클래스 사이의 결합을 피할수 있는 방법은 없다. 상속은 어떤 방식으로든 부모 클래스아 자식 클래스르 결합시킨다. 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느 정도 완화할 수 있지만 인스턴스 변수에 대한 잠재적인 결합을 제거할 수 잇는 방법은 없다. 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 사속 계층 전체에 걸쳐 부작용이 퍼지지 않게 하는 것이다.</p> <p>상속을 사용할 때 주의해야할 사항은 다음과 같다.</p> <ul><li>자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.</li> <li>상속받은 부모 클래스의 메서드가 자식 메서드의 규칙을 깨뜨릴 수 있다.</li> <li>자식 클래스가 부모 클래스를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방식에 자식 클래스가 결합될 수 있다.</li> <li>클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할수밖에 없다.</li></ul> <h2 id="_01-상속과-중복-코드">01. 상속과 중복 코드</h2> <p>중복 코드는 사람들의 마음속에 의심과 불신의 씨앗을 뿌린다.<br>
두 코드는 정말 동일한 것인가? 유사한 코드가 이미 존재하는데도 새로운 코드를 만든 이유가 무엇일까? 의도적인 것일까 아님 단순 실수인가? 중복을 없애도 문제가 없을 까? 양쪽 모두 수정하는 것 보다 한쪽만 수정하는 것이 더 안전한 방법 아닌가?(정말 공감!!!!)</p> <p>중복 코드는 변경을 방해한다. 이것이 중복을 제거해야 하는 가장 큰 이유이다. 프로그램은 항상 변화하고 코드도 그에 맞춰 변경되어야 한다.</p> <h3 id="dry-원칙">DRY 원칙</h3> <p>DRY는 '반복하지 마라'라는 뜻의 Don't Repeat Yourself의 첫 글자를 모아 만든 용어로 간단히 말해 동일한 지식을 중복하지 말란 뜻이다.</p> <h3 id="상속을-이용해서-중복을-제거하기">상속을 이용해서 중복을 제거하기</h3> <p>상속의 기본 아이디어는 매우 간단하다. 이미 존재하는 클래스와 유사한 클래스가 필요하면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하라는 것이다.</p> <p>하지만 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용 하는 것은 생각보다 쉽지 않다. 상속을 이용해 코드를 재사용 하기 위해서는 부모클래스의 개발자가 세웠던 가정이나 추론 과정을 정확하게 이해해야 한다. 따라서 상속은 결합도를 높인다. 그리고 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.</p> <h2 id="_02-취약한-기반-클래스-문제">02. 취약한 기반 클래스 문제</h2> <p>부모 클래스의 변경에 의해서 자식 클래스가 영향을 받는 현상을 <strong>취약한 기반 클래스 문제</strong> 라고 부른다. 취약한 기반 클래스 문제는 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어이다.</p> <p>상속은 자식클래스를 점진적으로 추가해서 기능을 확장하는데는 용이하지만 높은 결합도로 인해 부모클래스를 점진적으로 개선하기는 어렵게 만든다. 또한 상속은 자식 클래스가 부모클래스의 구현에 의존하게 만들기 때문에 캡슐화를 약하게 만든다.</p> <p>객체지향의 기반은 캡슐화를 통한 변경의 통제인데, 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향의 강력함을 반감시킨다. 몇가지 예를 통해 상속이 가지는 문제점을 알아보자.</p> <h3 id="불필요한-인터페이스-상속-문제">불필요한 인터페이스 상속 문제</h3> <p>Vector와 Vector를 상속받은 Stack을 살펴보자.</p> <p>위 그림의 퍼블릭 인터페이스를 보면 이 상속관계가 가지는 문제점을 잘 알 수 있다. Vector는 임의의 인덱스에서 여소를 조회하고, 추가하고, 삭제할 수 있는 get, add, remove 오퍼레이션을 제공한다. Stack은 push와 pop 오퍼레이션을 제공하는데 Vector의 오퍼레이션도 사용할 수 있으므로 임의의 위치에서 요소를 추가하거나 삭제할 수 있다. 따라서 맨 마지막 위치에서만 요소를 추가하거나 제거할 수 있도록 허용하는 Stack의 규칙을 위반해 버린다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;1st&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;2nd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;3rd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;4th&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">&quot;4th&quot;</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//에러!!!</span>
</code></pre></div><p>물론 Stack을 사용하는 개발자들이 Vector에서 상속받은 add메서드를 사용하지 않으면 된다고 생각할 수 있지만, 인터페이스는 제대로 쓰기는 쉽게 엉터리로 쓰기엔 어렵게 만들어야 한다.</p> <h3 id="메서드-오버라이딩의-오작용-문제">메서드 오버라이딩의 오작용 문제</h3> <p>이펙티브 자바(Joshua Bloch)에 소개된 내용 이다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InstrumentedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> addCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        addCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>
        addCount <span class="token operator">+=</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>HashSet의 구현에 강하게 결합된 InstrumentedHashSet 예 이다. 언뜻 보기엔 별 문제 없어 보이지만 아래 코드를 실행해 보면 예상과 다른 결과가 나옴을 확인할 수 있다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">InstrumentedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> languages <span class="token operator">=</span> <span class="token class-name">InstrumentedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
languages<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Ruby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Scala&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>딱 보면 위 코드를 실행 후 addCount값이 3이 될거라고 예상하겠지만 실제로 실행한 후의 addCount 값은 6이 된다. InstrumentedHashSet의 addAll 메서드가 호출되면 addCount에 3이 더해지고 super.addAll 메서드를 호출한다. 그런데 super.addAll 메서드는 내부적으로 add 메서드를 호출하고 결과적으로 InstrumentedHashSet의 add 메서드가 호출되어 addCount에 3이 더 더해지게 되는 것이다.</p> <p>당장엔 InstrumentedHashSet의 addAll 메서드에서 <code>addCount += c.size()</code>부분을 제거하면 되지만 나중에 HashSet의 addAll 메서드가 변경되면 InstrumentedHashSet의 addAll 메서드에도 영향이 갈 수밖에 없다.</p> <h3 id="부모-클래스와-자식-클래스의-동시-수정-문제">부모 클래스와 자식 클래스의 동시 수정 문제</h3> <p>상속은 기본적으로 부모 클래스의 내용을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알 것을 강요한다. 따라서 코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 함께 수정해야 하는 상황 역시 빈번하게 발생할수밖에 없다.</p> <h2 id="_03-상속을-제대로-사용하기">03. 상속을 제대로 사용하기</h2> <p>중복 제거를 위하여 이 책의 저자는 아래 방법을 사용한다고 한다.</p> <ul><li>두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.</li> <li>부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식으로 내리는 것 보다 자식 클래스의 추상적인 메서드를 부모로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.</li></ul> <h3 id="추상화에-의존하자">추상화에 의존하자</h3> <p>부모 자식 관계의 클래스가 강하게 결합되어 있으면 둘 다 추상화에 의존하도록 만들면 이 문제를 해결할 수 있다.</p> <h3 id="차이를-메서드로-추출하라">차이를 메서드로 추출하라</h3> <p>중복코드를 보고 둘 사이에 차이점을 별도의 메서드로 추출한다.</p> <h3 id="중복-코드를-부모-클래스로-올려라">중복 코드를 부모 클래스로 올려라</h3> <p>부모클래스를 추가한다. 모든 클래스가 추상화에 의존하도록 만드는 것이 목표이기 때문에 새로운 클래스는 추상클래스로 만든다.</p> <p>기존 클래스들의 공통부분을 부모클래스로 이동시킨다. 메서드의 시그니처는 같은데 구현만 다른 경우 메서드의 구현은 그대로 두고 시그니처만 이동시켜 추상메서드를 선언하고 자식클래스에서 오버라이딩 할 수 있도록 protected로 선언한다.</p> <h3 id="추상화가-핵심이다">추상화가 핵심이다</h3> <p>공통 코드를 이동 시킨 후에 보면 각 클래스는 서로 다른 변경의 이유를 가지게 된다. 각 클래스는 각각 하나의 변경 이유만 가지게 되므로 응집도가 높아진다.</p> <p>추상클래스의 추상메서드를 오버라이드 하는 경우에도 보면 추상메서드의 시그니처가 변경되지 않는 이상 부모클래스의 내부가 변경된다 해도 자식클래스는 영향을 받지 않는다.</p> <p>하위 클래스가 Abstract 클래스의 추상 메서드를 구현하게 되므로(상위 정책에 의존을 하게 된다) 의존성 역전 원칙도 준수하게 된다.</p> <p>새로운 기능이 필요한 경우도 추상 클래스를 상속받아 새로운 기능을 구현한 구체클래스를 만들면 되므로 확장에 대해 열려있고 수정에 대해 닫혀있는 설계를 만족한다. 개방-폐쇄 원칙 또한 준수한다고 할 수 있다.</p> <h3 id="의도를-드러내는-이름-선택하기">의도를 드러내는 이름 선택하기</h3> <p>클래스, 메서드 모두 그 자신의 의도를 잘 드러내는 이름을 선택해야 한다. 추상클래스는 좀 더 포괄적인 이름을, 구체클래스는 특성을 잘 드러내는 이름을 선택해야 한다.</p> <h3 id="요구사항-추가하기">요구사항 추가하기</h3> <p>인스턴스 변수의 목록이 변하지 않은 상황에서 객체의 행동만 변경된다면 상속 계층에 속한 각 클래스들을 독립적으로 잔화시킬 수 있다. 하지만 인스턴스 변수가 추가되는 경우는 그렇지 못하다. 자식클래스는 자신의 인스턴스를 생성할 때 부모클래스에서 정의된 인스턴스 변수를 초기화 해야 하기 때문에 자연스럽게 부모 클래스에 추가된 인스턴스 변수는 자식클래스의 초기화로직에 영향을 미치게 된다. 책임을 아무리 잘 분리해도 인스턴스변수의 추가는 종종 상속 계층 전반에 걸친 변화를 유발한다.</p> <p>상속으로 인한 클래스 사이의 결합을 피할수 있는 방법은 없다. 상속은 어떤 방식으로든 부모 클래스아 자식 클래스르 결합시킨다. 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느 정도 완화할 수 있지만 인스턴스 변수에 대한 잠재적인 결합을 제거할 수 잇는 방법은 없다. 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 사속 계층 전체에 걸쳐 부작용이 퍼지지 않게 하는 것이다.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study/book/object/9-유연한_설계.html" class="prev">9. 유연한 설계</a></span> <span class="next"><a href="/study/book/object/11-합성과_유연한_설계.html">11. 합성과 유연한 설계</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1ac8e472.js" defer></script><script src="/assets/js/2.2f398f54.js" defer></script><script src="/assets/js/64.a6b87c8a.js" defer></script>
  </body>
</html>
